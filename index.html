<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>4H 爆拉模型（冷啟動 + WS）</title>
<style>
body{background:#111;color:#fff;font-family:Arial;padding:20px}
button{padding:10px 15px;font-size:16px}
.card{background:#222;padding:15px;margin-top:20px;border-radius:8px}
pre{background:#000;padding:10px;height:200px;overflow:auto}
</style>
</head>
<body>

<h1>4H >8% 爆拉機率（冷啟動一次）</h1>
<button onclick="init()">初始化 / 重算</button>

<div class="card">
<h2>Top5</h2>
<ul id="top5"></ul>
</div>

<div class="card">
<h2>日誌</h2>
<pre id="logs"></pre>
</div>

<script>
const BINANCE="https://fapi.binance.com";
const STORAGE_KEY="marketData30d";
const BATCH=3;
const SLEEP=1000;

function log(t){document.getElementById("logs").innerText+=t+"\n";}
function sleep(ms){return new Promise(r=>setTimeout(r,ms));}
function sigmoid(z){return 1/(1+Math.exp(-z));}

// ===== 技術指標 =====
function EMA(data,p){
  const k=2/(p+1);
  let ema=data[0];
  for(let i=1;i<data.length;i++)
    ema=data[i]*k+ema*(1-k);
  return ema;
}

function RSI(closes,p=48){
  let g=0,l=0;
  for(let i=closes.length-p;i<closes.length;i++){
    let d=closes[i]-closes[i-1];
    if(d>0)g+=d;else l-=d;
  }
  let rs=g/(l||1);
  return 100-(100/(1+rs));
}

// ===== REST 抓30天 =====
async function fetch30d(symbol){
  const now=Date.now();
  const start=now-30*24*60*60*1000;
  const url=`${BINANCE}/fapi/v1/klines?symbol=${symbol}&interval=5m&limit=1500&startTime=${start}`;
  const r=await fetch(url);
  return await r.json();
}

// ===== 冷啟動 =====
async function init(){

  log("檢查是否已有資料...");
  let marketData=JSON.parse(localStorage.getItem(STORAGE_KEY));

  if(!marketData){

    log("首次啟動，開始慢速抓取...");

    const ex=await fetch(BINANCE+"/fapi/v1/exchangeInfo");
    const exData=await ex.json();
    const symbols=exData.symbols
      .filter(s=>s.contractType==="PERPETUAL"&&s.quoteAsset==="USDT")
      .map(s=>s.symbol);

    marketData={};

    for(let i=0;i<symbols.length;i+=BATCH){

      const part=symbols.slice(i,i+BATCH);

      await Promise.all(part.map(async sym=>{
        try{
          const data=await fetch30d(sym);
          if(data.length>1000)
            marketData[sym]=data;
        }catch(e){}
      }));

      log("進度: "+Math.min(i+BATCH,symbols.length)+"/"+symbols.length);
      await sleep(SLEEP);
    }

    localStorage.setItem(STORAGE_KEY,JSON.stringify(marketData));
    log("冷啟動完成並儲存");
  }else{
    log("已存在本地資料，跳過抓取");
  }

  calculate();
  startWS();
}

// ===== 計算模型 =====
function calculate(){

  const marketData=JSON.parse(localStorage.getItem(STORAGE_KEY));
  let results=[];

  for(const sym in marketData){

    const raw=marketData[sym];
    const closes=raw.map(x=>+x[4]);
    if(closes.length<200) continue;

    const latestRSI=RSI(closes)/100;
    const ema24=EMA(closes.slice(-120),24);
    const ema96=EMA(closes.slice(-120),96);
    const spread=(ema24-ema96)/ema96;
    const macd=ema24-ema96;

    const z=-3 + 2*latestRSI + 5*spread + 0.0001*macd;
    const prob=sigmoid(z);

    results.push({symbol:sym,prob});
  }

  results.sort((a,b)=>b.prob-a.prob);
  const top5=results.slice(0,5);

  document.getElementById("top5").innerHTML=
    top5.map(x=>`<li>${x.symbol} | 爆拉機率: ${(x.prob*100).toFixed(2)}%</li>`).join("");

  log("模型重算完成");
}

// ===== WebSocket 更新 =====
function startWS(){

  const marketData=JSON.parse(localStorage.getItem(STORAGE_KEY));
  const symbols=Object.keys(marketData).slice(0,20);

  const streams=symbols.map(s=>s.toLowerCase()+"@kline_5m").join("/");
  const ws=new WebSocket("wss://fstream.binance.com/stream?streams="+streams);

  ws.onmessage=(msg)=>{
    const data=JSON.parse(msg.data);
    const k=data.data.k;
    if(k.x){ // 收盤
      const sym=k.s;
      marketData[sym].push([
        k.t,0,0,0,k.c,k.v
      ]);
      if(marketData[sym].length>9000)
        marketData[sym].shift();
      localStorage.setItem(STORAGE_KEY,JSON.stringify(marketData));
      calculate();
    }
  };

  log("WebSocket 已啟動");
}

</script>
</body>
</html>
